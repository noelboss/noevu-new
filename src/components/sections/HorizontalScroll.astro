---
/**
 * HorizontalScroll - Transforms vertical scroll into horizontal panel movement
 * Ported from original noevu.ch Squarespace implementation
 *
 * Structure (matching original):
 * - .horizontal-scroll-section: outer section with theme
 * - .horizontal-scroll__wrapper: height container (position: relative, dynamic height via JS)
 * - .horizontal-scroll__container: sticky element that transforms (position: sticky, width: max-content)
 * - .horizontal-scroll__panel: individual 100vw panels
 */
import type { Theme } from '../../schemas/sections';
import { parseInlineMarkdown } from '../../utils/markdown';

interface HorizontalScrollItem {
  eyebrow?: string;
  number?: string;
  title: string;
  description: string;
  image?: {
    src: string;
    alt: string;
  };
  cta?: {
    label: string;
    href: string;
    variant?: string;
    icon?: string;
  };
}

interface Props {
  data: {
    headline?: string;
    steps?: HorizontalScrollItem[];
    items?: HorizontalScrollItem[];
    theme?: Theme;
  };
  theme?: Theme;
}

const { data, theme: propTheme } = Astro.props;
const { headline } = data;
const items = data.steps || data.items || [];
const theme = data.theme || propTheme || 'dark';
const parsedHeadline = headline ? parseInlineMarkdown(headline) : null;
---

<section class="horizontal-scroll-section" data-theme={theme}>
  {parsedHeadline && (
    <div class="horizontal-scroll__header container">
      <h2 class="horizontal-scroll__title" set:html={parsedHeadline} />
    </div>
  )}

  <div class="horizontal-scroll__wrapper" data-panel-count={items.length}>
    <div class="horizontal-scroll__container">
      {items.map((item, index) => {
        const eyebrow = item.eyebrow || (item.number ? `${item.number}.` : '');
        return (
          <section class="horizontal-scroll__panel" data-panel-index={index} id={`scroll-${index + 1}`}>
            <div class="horizontal-scroll__panel-inner">
              {item.image && (
                <div class="horizontal-scroll__image">
                  <img
                    src={item.image.src}
                    alt={item.image.alt}
                    loading={index === 0 ? 'eager' : 'lazy'}
                  />
                </div>
              )}

              <div class="horizontal-scroll__content">
                {eyebrow && (
                  <span class="horizontal-scroll__eyebrow" set:html={parseInlineMarkdown(eyebrow)} />
                )}
                <h3 class="horizontal-scroll__item-title" set:html={parseInlineMarkdown(item.title)} />
                <div class="horizontal-scroll__description" set:html={parseInlineMarkdown(item.description)} />

                {item.cta && (
                  <a href={item.cta.href} class="horizontal-scroll__cta">
                    {item.cta.label}
                    <span class="material-symbols-outlined">{item.cta.icon || 'chat'}</span>
                  </a>
                )}
              </div>
            </div>
          </section>
        );
      })}
    </div>

    <!-- Progress indicators (fixed position within wrapper) -->
    <div class="horizontal-scroll__progress">
      {items.map((_, index) => (
        <button
          class="horizontal-scroll__dot"
          data-index={index}
          aria-label={`Go to panel ${index + 1}`}
        />
      ))}
    </div>
  </div>
</section>

<style>
  /* ═══════════════════════════════════════════════════════════════
     CSS VARIABLES
     ═══════════════════════════════════════════════════════════════ */
  .horizontal-scroll-section {
    --panel-gap: 0;
    --content-max-width: 500px;
    --image-max-size: 500px;

    position: relative;
    background: var(--theme-bg, var(--color-green-dark, #141110));
    color: var(--theme-text, var(--color-white));
  }

  /* ═══════════════════════════════════════════════════════════════
     HEADER
     ═══════════════════════════════════════════════════════════════ */
  .horizontal-scroll__header {
    padding-top: var(--space-16);
    padding-bottom: var(--space-8);
    text-align: center;
  }

  .horizontal-scroll__title {
    font-size: var(--text-3xl);
    color: var(--theme-heading, var(--color-white));
    max-width: 800px;
    margin-inline: auto;
  }

  .horizontal-scroll__title :global(strong),
  .horizontal-scroll__title :global(em) {
    color: var(--color-orange, #ff6b30);
    font-style: normal;
  }

  /* ═══════════════════════════════════════════════════════════════
     WRAPPER - Creates the scroll height (matching original .horizontal-section)
     Height set dynamically by JS: scrollDistance + viewportHeight
     ═══════════════════════════════════════════════════════════════ */
  .horizontal-scroll__wrapper {
    position: relative;
    /* Prevent horizontal overflow on the wrapper */
    overflow-x: clip;
  }

  @supports not (overflow-x: clip) {
    .horizontal-scroll__wrapper {
      overflow-x: hidden;
    }
  }

  /* ═══════════════════════════════════════════════════════════════
     CONTAINER - Sticky element that transforms horizontally
     (matching original .horizontal-container)
     ═══════════════════════════════════════════════════════════════ */
  .horizontal-scroll__container {
    /* Mobile first - vertical stacking */
    display: block;
    width: 100%;
  }

  @media (min-width: 769px) {
    .horizontal-scroll__container {
      position: sticky;
      top: 0;
      left: 0;
      height: 100vh;
      display: flex;
      width: max-content;
      /* GPU acceleration for smooth transforms */
      will-change: transform;
      backface-visibility: hidden;
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      -webkit-transform: translateZ(0);
      -webkit-font-smoothing: subpixel-antialiased;
    }
  }

  /* ═══════════════════════════════════════════════════════════════
     PANEL - Individual 100vw sections
     (matching original .horizontal-scroll-section)
     ═══════════════════════════════════════════════════════════════ */
  .horizontal-scroll__panel {
    width: 100vw;
    max-width: 100vw;
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--space-8);
    box-sizing: border-box;
    /* Reset default section margins */
    margin: 0;
  }

  @media (min-width: 769px) {
    .horizontal-scroll__panel {
      flex: 0 0 100vw;
      height: 100vh;
      min-height: 100vh;
      /* GPU acceleration */
      backface-visibility: hidden;
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      -webkit-transform: translateZ(0);
      -webkit-font-smoothing: subpixel-antialiased;
    }

    /* Remove padding from first panel */
    .horizontal-scroll__panel:first-child {
      padding-top: 0;
    }
  }

  .horizontal-scroll__panel-inner {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-12);
    max-width: 1200px;
    width: 100%;
    align-items: center;
  }

  /* Alternate layout: odd panels have image on left, even on right */
  .horizontal-scroll__panel:nth-child(even) .horizontal-scroll__panel-inner {
    direction: rtl;
  }

  .horizontal-scroll__panel:nth-child(even) .horizontal-scroll__panel-inner > * {
    direction: ltr;
  }

  /* ═══════════════════════════════════════════════════════════════
     IMAGE
     ═══════════════════════════════════════════════════════════════ */
  .horizontal-scroll__image {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .horizontal-scroll__image img {
    max-width: var(--image-max-size);
    max-height: 70vh;
    width: 100%;
    height: auto;
    object-fit: contain;
    border-radius: var(--radius-lg);
  }

  /* ═══════════════════════════════════════════════════════════════
     CONTENT
     ═══════════════════════════════════════════════════════════════ */
  .horizontal-scroll__content {
    max-width: var(--content-max-width);
  }

  .horizontal-scroll__eyebrow {
    display: block;
    font-size: var(--text-sm);
    font-weight: var(--font-semibold);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--color-orange, #ff6b30);
    margin-bottom: var(--space-3);
  }

  .horizontal-scroll__eyebrow :global(strong) {
    font-weight: inherit;
  }

  .horizontal-scroll__item-title {
    font-size: var(--text-2xl);
    font-weight: var(--font-bold);
    color: var(--theme-heading, var(--color-white));
    margin-bottom: var(--space-4);
    line-height: 1.2;
  }

  .horizontal-scroll__item-title :global(strong),
  .horizontal-scroll__item-title :global(em) {
    color: var(--color-orange, #ff6b30);
    font-style: normal;
    font-weight: inherit;
  }

  .horizontal-scroll__description {
    font-size: var(--text-base);
    color: var(--theme-text-muted, hsla(var(--color-white-hsl), 0.8));
    line-height: var(--leading-relaxed);
    margin-bottom: var(--space-6);
  }

  .horizontal-scroll__description :global(a) {
    color: var(--color-orange, #ff6b30);
    text-decoration: underline;
    text-underline-offset: 2px;
  }

  .horizontal-scroll__description :global(a:hover) {
    text-decoration: none;
  }

  .horizontal-scroll__cta {
    display: inline-flex;
    align-items: center;
    gap: var(--space-2);
    color: var(--theme-text, var(--color-white));
    font-weight: var(--font-medium);
    text-decoration: none;
    transition: color 0.2s ease;
    padding-left: var(--space-6);
    position: relative;
  }

  .horizontal-scroll__cta::before {
    content: '';
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: var(--space-4);
    height: 1px;
    background: currentColor;
    opacity: 0.5;
  }

  .horizontal-scroll__cta:hover {
    color: var(--color-orange, #ff6b30);
  }

  .horizontal-scroll__cta .material-symbols-outlined {
    font-size: 1.25rem;
    text-decoration: line-through;
    opacity: 0.7;
  }

  /* ═══════════════════════════════════════════════════════════════
     PROGRESS INDICATORS - Fixed at bottom of viewport during scroll
     ═══════════════════════════════════════════════════════════════ */
  .horizontal-scroll__progress {
    display: none;
  }

  @media (min-width: 769px) {
    .horizontal-scroll__progress {
      display: flex;
      position: fixed;
      bottom: var(--space-8);
      left: 50%;
      transform: translateX(-50%);
      gap: var(--space-3);
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .horizontal-scroll__wrapper.is-active .horizontal-scroll__progress {
      opacity: 1;
      pointer-events: auto;
    }
  }

  .horizontal-scroll__dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 2px solid hsla(var(--color-white-hsl), 0.4);
    background: transparent;
    cursor: pointer;
    transition: all 0.3s ease;
    padding: 0;
  }

  .horizontal-scroll__dot:hover {
    border-color: hsla(var(--color-white-hsl), 0.7);
  }

  .horizontal-scroll__dot.active {
    background: var(--color-orange, #ff6b30);
    border-color: var(--color-orange, #ff6b30);
    transform: scale(1.2);
  }

  /* ═══════════════════════════════════════════════════════════════
     MOBILE LAYOUT - Vertical stack (< 769px)
     ═══════════════════════════════════════════════════════════════ */
  @media (max-width: 768px) {
    .horizontal-scroll__wrapper {
      height: auto !important;
    }

    .horizontal-scroll__container {
      transform: none !important;
    }

    .horizontal-scroll__panel {
      width: 100%;
      height: auto;
      min-height: auto;
      padding: var(--space-12) var(--space-4);
      padding-top: 0;
    }

    .horizontal-scroll__panel-inner {
      grid-template-columns: 1fr;
      gap: var(--space-6);
      text-align: center;
    }

    .horizontal-scroll__panel:nth-child(even) .horizontal-scroll__panel-inner {
      direction: ltr;
    }

    .horizontal-scroll__image {
      order: -1;
    }

    .horizontal-scroll__image img {
      max-width: 280px;
      max-height: 280px;
    }

    .horizontal-scroll__content {
      max-width: none;
    }

    .horizontal-scroll__cta {
      justify-content: center;
      padding-left: 0;
    }

    .horizontal-scroll__cta::before {
      display: none;
    }
  }

  /* ═══════════════════════════════════════════════════════════════
     LIGHT THEME ADJUSTMENTS
     ═══════════════════════════════════════════════════════════════ */
  [data-theme="light"] .horizontal-scroll-section,
  [data-theme="beige"] .horizontal-scroll-section {
    --theme-bg: var(--color-white);
    --theme-text: var(--color-text);
    --theme-heading: var(--color-text);
    --theme-text-muted: var(--color-text-muted);
  }

  [data-theme="light"] .horizontal-scroll__dot,
  [data-theme="beige"] .horizontal-scroll__dot {
    border-color: hsla(var(--color-text-hsl), 0.3);
  }

  [data-theme="light"] .horizontal-scroll__dot:hover,
  [data-theme="beige"] .horizontal-scroll__dot:hover {
    border-color: hsla(var(--color-text-hsl), 0.6);
  }
</style>

<script>
  /**
   * Horizontal scroll animation - transforms vertical scroll to horizontal movement
   * Ported from original noevu.ch implementation (global/horizontal-scroll.js)
   *
   * Key mechanics:
   * 1. wrapper height = scrollDistance + viewportHeight (creates vertical scroll room)
   * 2. container is sticky, transforms horizontally based on scroll position
   * 3. scrollDistance = container.scrollWidth - viewportWidth
   * 4. transform = translateX(-offset) clamped to [0, scrollDistance]
   */

  function initHorizontalScroll() {
    const wrappers = document.querySelectorAll('.horizontal-scroll__wrapper');

    wrappers.forEach((wrapper) => {
      const container = wrapper.querySelector('.horizontal-scroll__container') as HTMLElement;
      const panels = wrapper.querySelectorAll('.horizontal-scroll__panel');
      const dots = wrapper.querySelectorAll('.horizontal-scroll__dot');
      const panelCount = panels.length;
      const wrapperEl = wrapper as HTMLElement;

      if (!container || panelCount === 0) return;

      let scrollDistance = 0;

      // Recalculate dimensions on resize
      const recalculate = () => {
        // Only apply horizontal scroll on desktop (>= 769px, matching original)
        if (window.innerWidth < 769) {
          wrapperEl.style.height = '';
          container.style.transform = '';
          wrapperEl.classList.remove('is-active');
          return false;
        }

        // scrollDistance = total horizontal scroll distance
        // (total content width - one viewport width)
        scrollDistance = container.scrollWidth - window.innerWidth;

        // Set wrapper height to create vertical scroll room
        // Height = scrollDistance + viewportHeight
        // This means: scrolling viewportHeight pixels vertically = scrollDistance pixels horizontally
        if (scrollDistance > 0) {
          wrapperEl.style.height = `${scrollDistance + window.innerHeight}px`;
        }

        return true;
      };

      // Handle scroll event
      const onScroll = () => {
        // Skip on mobile
        if (window.innerWidth < 769) return;

        // Calculate vertical offset from top of wrapper
        // Use getBoundingClientRect for accurate position relative to viewport
        const wrapperRect = wrapperEl.getBoundingClientRect();
        const offset = -wrapperRect.top;

        // Clamp offset between 0 and scrollDistance
        const clamped = Math.min(Math.max(offset, 0), scrollDistance);

        // Calculate percentage for dot indicators
        const pct = scrollDistance > 0 ? clamped / scrollDistance : 0;

        // Apply horizontal transform (negative = move left)
        container.style.transform = `translateX(-${clamped}px)`;

        // Toggle active class when we're within the scroll section
        const isInSection = offset > 0 && offset < scrollDistance;
        wrapperEl.classList.toggle('is-active', isInSection || (offset >= 0 && offset <= scrollDistance));

        // Update active dot based on progress
        if (scrollDistance > 0 && panelCount > 0) {
          // Calculate which panel is most visible
          const activeIndex = Math.min(
            Math.floor(pct * panelCount),
            panelCount - 1
          );

          dots.forEach((dot, i) => {
            dot.classList.toggle('active', i === activeIndex);
          });
        }
      };

      // Scroll to specific panel when dot is clicked
      const scrollToPanel = (index: number) => {
        if (scrollDistance <= 0 || panelCount <= 1) return;

        // Each panel takes up scrollDistance / (panelCount - 1) of vertical scroll
        // But we want to scroll to the start of each panel
        const panelScrollWidth = window.innerWidth; // Each panel is 100vw
        const targetHorizontalOffset = panelScrollWidth * index;

        // Clamp to scrollDistance
        const clampedOffset = Math.min(targetHorizontalOffset, scrollDistance);

        // Convert to vertical scroll position
        const targetScroll = wrapperEl.offsetTop + clampedOffset;

        window.scrollTo({
          top: targetScroll,
          behavior: 'smooth'
        });
      };

      // Throttled scroll handler
      let ticking = false;
      window.addEventListener('scroll', () => {
        if (!ticking) {
          requestAnimationFrame(() => {
            onScroll();
            ticking = false;
          });
          ticking = true;
        }
      });

      // Recalculate on resize
      window.addEventListener('resize', () => {
        recalculate();
        onScroll();
      });

      // Dot click handlers
      dots.forEach((dot, index) => {
        dot.addEventListener('click', () => {
          scrollToPanel(index);
        });
      });

      // Initial setup
      recalculate();
      onScroll();
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHorizontalScroll);
  } else {
    initHorizontalScroll();
  }
</script>
